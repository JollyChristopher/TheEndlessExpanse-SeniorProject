package halemaster.ee.world.history.event.type;

import halemaster.ee.world.Area;
import halemaster.ee.world.history.event.Event;
import halemaster.ee.world.history.event.EventHolder;
import halemaster.ee.world.history.event.structures.EventObject;
import halemaster.ee.world.history.event.structures.EventObjectType;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

/**
 * @name EventMapper
 * 
 * @version 0.0.0
 * 
 * @date Nov 19, 2013
 */
public class EventMapper 
{
  private EventType type;
  private Map<String, List<Event>> parents = 
          new HashMap<String, List<Event>>();
  
  /**
   * create the event in the holder given the values.
   * 
   * @param holder holder to create event in.
   * @param random random to use for creation.
   * @param date date the event happens on.
   * @param area area the event happens in.
   * @param lockEvents whether to lock events in the holder based on this event.
   * @throws InstantiationException
   * @throws IllegalAccessException 
   */
  public void createEvent (EventHolder holder, Random random, int date,
          Area area, boolean lockEvents) throws InstantiationException, 
          IllegalAccessException
  {
    Event event;
    Event parent;
    EventObject obj;
    
    if (canCreateEvent ())
    {      
      // 1. Fill out event type, date, lock, Location, and Holder
      event = new Event ();
      event.setType (this.type);
      event.setDate (date);
      event.setLock (lockEvents);
      event.setLocation (area.getX (), area.getY ());
      event.setHolder (holder);
      
      // 2. Fill vars from dependencies
      for (String id : this.type.getDependenciesIds ())
      {
        for (Map<String, String> dep : this.type.getDependencies (id))
        {
          parent = this.parents.get (id).get 
                  (random.nextInt (this.parents.get (id).size ()));
          this.parents.get (id).remove (parent);
          
          for (Entry<String, String> var : dep.entrySet ())
          {
            event.addVariable (var.getKey (), 
                    parent.getVariable (var.getValue ()));
          }
        }
      } 
      
      // 3. Initialize remaining variables
      for (String var : this.type.getVariables ())
      {
        if (null == event.getVariable (var))
        {
          obj = EventObjectType.getByType (this.type.getVariableType (var))
                  .getObject (random);
          event.addVariable (var, obj);
        }
      }
      
      // 4. Modify event
      for (String change : this.type.getChangesIds ())
      {
        for (Entry<String, String> modifiers : 
                this.type.getChanges (change).entrySet ())
        {
          event.getVariable (change).modify (event.getVariable 
                  (modifiers.getKey ()), modifiers.getValue ());
        }
      }
      
      // 5. Add to holder
      holder.addEvent (event, lockEvents);
    }
  }
  
  /**
   * Determine whether this mapper is able to be turned into an event.
   * 
   * @return whether this mapper can create an event.
   */
  public boolean canCreateEvent ()
  {
    boolean canCreate = true;
    
    for (String id : this.type.getDependenciesIds ())
    {
      if (this.type.getDependencies (id).size () > 
              this.parents.get (id).size ())
      {
        canCreate = false;
      }
    }
    
    return canCreate;
  }

  public void setType (EventType type)
  {
    this.type = type;
  }
  
  public EventType getType ()
  {
    return this.type;
  }
  
  /**
   * Add the given event as a parent to this mapper.
   * 
   * @param event event to add as a parent for this mapper.
   */
  public void addParent (Event event)
  {
    String[] dependencies = this.type.getDependenciesIds ();
    List<Event> parentSet;
    
    for (String dep : dependencies)
    {
      if (event.countsAs (dep))
      {
        parentSet = this.parents.get (dep);
        if (null == parentSet)
        {
          parentSet = new ArrayList<Event> ();
          this.parents.put (dep, parentSet);
        }
        parentSet.add (event);
      }
    }
  }
}
